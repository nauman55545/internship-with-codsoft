# -*- coding: utf-8 -*-
"""movie_task2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aOiVVNJ3mt5tfnaFugB7R028kGcgUDx8
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px

from google.colab import files
uploaded = files.upload()

#md = movies dataset
import io
md=pd.read_csv((io.BytesIO(uploaded['IMDb Movies India.csv'])), encoding='unicode_escape')

md.info()

md.shape

md.isna().sum()

md.describe()

q1=4.9000
q2=6.8000
IQR=q2-q1
IQR

q1=4.9000
q2=6.8000
IQR=q2-q1
IQR

lower_limb=q1-(1.5*IQR)

boxplot = md.boxplot(column=['Rating'])
lower_limb=q1-(1.5*IQR)
plt.axhline(lower_limb,  label='pyplot vertical line')
plt.legend()

md.dropna(subset=['Rating','Year'], inplace=True)

md['Rating']

md.hist(column=['Rating'])

md['Genre'].unique()

md['Rating'].max()

md.loc[md['Rating'] == md['Rating'].max()]

md.loc[md['Rating'] == md['Rating'].min()]

md.loc[md['Votes']==md['Votes'].max()]

md

md['Votes']=md['Votes'].str.replace(",","")

md['Votes']=md['Votes'].astype(int)

md['Votes'].dtypes

plt.scatter(md["Votes"],md["Rating"],color="red")
plt.show()

sns.kdeplot(data=md, x='Votes',color="green")
plt.title(' Estimate of Votes ' )
plt.show()

md.dropna(subset=['Genre'], inplace=True)

data=md.reset_index()

md.head()

list_Genre=[]
list_Genre=data['Genre'].str.split(",")
list_Genre

Genre=[]
for x in list_Genre:
  Genre.extend(x)

Genre

Genres=[i.strip() for i in Genre]

movies_data2=pd.DataFrame(Genres)

movies_data2

movies_data2.columns=['Genre']

count_of_genre=movies_data2["Genre"].value_counts()
count_of_genre

listOfGenre=movies_data2["Genre"].unique()
listOfGenre

len(listOfGenre)

labels = listOfGenre
assert len(labels) == len(count_of_genre), "Mismatch between labels and genre counts."
plt.figure(figsize=(14, 6))
colors = plt.cm.tab20(np.linspace(0, 1, len(labels)))
plt.bar(labels, count_of_genre, color=colors)
plt.xticks(rotation=45, ha='right')
plt.xlabel('Genres')
plt.ylabel('Count')
plt.title('Count of Genre')
plt.tight_layout()
plt.show()

Genres = movies_data2['Genre'].value_counts()
top_Genre = Genres.head(10)
plt.figure(figsize=(8, 8))
colors = plt.cm.viridis(np.linspace(0.6, 0.8, len(top_Genre)))
plt.pie(top_Genre.values, labels=top_Genre.index, colors=colors, autopct='%.1f%%')
plt.title('Top 10 Genres with the Total Number of Movies')
plt.show()

colors = plt.cm.tab20.colors
colors = colors[:len(listOfGenre)]
plt.figure(figsize=(12, 8))
plt.barh(listOfGenre, count_of_genre, color=colors)
plt.title('Count of Genre')
plt.xlabel('Count of Genre')
plt.ylabel('List of Genre')
plt.tight_layout()
plt.show()

Year = md['Year'].value_counts()

top_Year=Year.head(10)
plt.figure(figsize=(8, 8))
colors=plt.cm.viridis(np.linspace(0.6, 0.8, len(top_Year)))
plt.pie(top_Year.values, labels=top_Year.index, colors=colors, autopct='%.1f%%')
plt.title('Top 10 Movies In Total 10 Year')
plt.show()

md['Director'].fillna('Unknown', inplace=True)
top_directors = md['Director'].value_counts().head(10)
plt.figure(figsize=(8, 8))
colors = plt.cm.Set3(np.linspace(0, 1, len(top_directors)))
plt.pie(top_directors.values, labels=top_directors.index, autopct='%.1f%%', colors=colors, startangle=140)
plt.title('Top 10 Directors of Number of Movies')
plt.axis('equal')
plt.show()

md['Actor 1'].fillna('Unknown', inplace=True)
Top_actors = md['Actor 1'].value_counts().head(10)
plt.figure(figsize=(8, 8))
colors = plt.cm.viridis(np.linspace(0.6, 0.8, len(Top_actors)))
plt.pie(Top_actors.values, labels=Top_actors.index, autopct='%.1f%%', colors=colors, startangle=140)
plt.title('Top 10 Actors (Actor 1) of Number of Movies')
plt.show()

md.info()

listOfRate = md['Rating'].values.tolist()
listOfRate

rate=[]
for i in range(len(list_Genre)):
    for j in range(len(list_Genre[i])):
           rate.append(listOfRate[i])

rate

md_rating=pd.DataFrame(rate)

md_rating.columns=['ratings']

movies_data2=movies_data2.merge(md_rating,left_index=True, right_index=True)

movies_data2.head()

movies_data2.value_counts()

avg_ratings=movies_data2.groupby('Genre')['ratings'].mean()
avg_ratings

plt.barh(avg_ratings.index,avg_ratings.values)
plt.xlabel("Avg Rating")
plt.ylabel("Genre")
plt.title("Avg rating of Genre")
plt.show()

md['Year'].unique()

year=md['Year'].value_counts()
year

md['Year']=md['Year'].str.replace("(","")
md['Year']=md['Year'].str.replace(")","")

md['Year']=md['Year'].astype(int)

colors = plt.cm.Set3(np.linspace(0, 1, len(year)))
plt.figure(figsize=(20, 10))
plt.bar(year.index, year.values, color=colors)
plt.xlabel("Year of Movie Release")
plt.ylabel("Count of Movies Released")
plt.title("Number of Movies Released by Year")
plt.xticks(rotation='vertical', fontsize=8)
plt.tight_layout()
plt.show()

md.loc[md['Rating'].max()==md['Rating']]['Name']

md['Duration']=md['Duration'].str.replace('min','')

md['Duration']=md['Duration'].str.replace('max','')

md.dropna(subset=['Duration'], inplace=True)

md['Duration']=md['Duration'].astype(int)

md['Duration']

md['Duration'].dtype

plt.figure(figsize=(8, 8))
sns.pairplot(md, height=2.5)
plt.show()

correlation_matrix = md[['Year','Duration','Rating','Votes']].corr().round(2)
sns.set(rc={'figure.figsize':(11.7,8.27)})
sns.heatmap(data=correlation_matrix, annot=True)

from sklearn import preprocessing

label_encoder = preprocessing.LabelEncoder()
md['Actor 1']= label_encoder.fit_transform(md['Actor 1'])

md['Actor 1']

md['Actor 2']= label_encoder.fit_transform(md['Actor 2'])

md['Actor 2']

md['Actor 3']= label_encoder.fit_transform(md['Actor 3'])

md['Actor 3']

md['Director']= label_encoder.fit_transform(md['Director'])

x=md[['Actor 1','Actor 2','Actor 3','Director']]
y=md['Rating']

import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense
from tensorflow.keras.optimizers import Adam
from sklearn.model_selection import train_test_split

x_train,x_test,y_train,y_test=train_test_split(x, y, test_size=0.2, random_state=1)

model = Sequential([
    Dense(64, activation='relu', input_shape=(x_train.shape[1],)), # Add a dense layer with ReLU activation
    Dense(32, activation='relu'), # Add another dense layer
    Dense(1) # Output layer for regression (predicting a single value: rating)
])

optimizer=Adam(learning_rate=0.01)
model.compile(optimizer=optimizer, loss=tf.keras.losses.MeanSquaredError(), metrics=['mse'])

model.fit(x_train,y_train,epochs=30)

model.evaluate(x_test,y_test)

y_pred = model.predict(x_test)
print("y predict is: ",y_pred)